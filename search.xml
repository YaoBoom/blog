<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Redis面试</title>
      <link href="/2024/08/02/Redis%E9%9D%A2%E8%AF%95/"/>
      <url>/2024/08/02/Redis%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis面试"><a href="#Redis面试" class="headerlink" title="Redis面试"></a>Redis面试</h2><h4 id="Redis主从"><a href="#Redis主从" class="headerlink" title="Redis主从"></a>Redis主从</h4><img src="/img/微服务面试/1.1.png" alt="image-20240824154926853" style="zoom: 67%;" /><p>如图所示，集群中有一个master节点、两个slave节点（现在叫replica）。当我们通过Redis的Java客户端访问主从集群时，应该做好路由：</p><ul><li>如果是<strong>写操作</strong>，应该访问master节点，master会自动将数据同步给两个slave节点</li><li>如果是<strong>读操作</strong>，建议访问各个slave节点，从而分担并发压力</li></ul><p>创建、启动Redis实例后，并不会自动形成<strong>主从关系</strong>，需要通过命令来配置关系</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Redis5.0以前</span></span><br><span class="line">slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br><span class="line"><span class="comment"># Redis5.0以后</span></span><br><span class="line">replicaof &lt;masterip&gt; &lt;masterport&gt;</span><br></pre></td></tr></table></figure><p>有临时和永久两种模式：</p><ul><li>永久生效：在redis.conf文件中利用<code>slaveof</code>命令指定<code>master</code>节点</li><li>临时生效：直接利用redis-cli控制台输入<code>slaveof</code>命令，指定<code>master</code>节点</li></ul><p><strong>主从同步原理</strong></p><img src="/img/微服务面试/1.2.png" alt="image-20240824170605490" style="zoom:67%;" /><h5 id="全量同步"><a href="#全量同步" class="headerlink" title="全量同步"></a><strong>全量同步</strong></h5><img src="/img/微服务面试/1.3.png" alt="image-20240824172657901" style="zoom:67%;" /><p>完整流程描述：</p><ul><li><code>slave</code>节点请求增量同步</li><li><code>master</code>节点判断<code>replid</code>，发现不一致，拒绝增量同步</li><li><code>master</code>将完整内存数据生成<code>RDB</code>，发送<code>RDB</code>到<code>slave</code></li><li><code>slave</code>清空本地数据，加载<code>master</code>的<code>RDB</code></li><li><code>master</code>将<code>RDB</code>期间的命令记录在<code>repl_baklog</code>，并持续将log中的命令发送给<code>slave</code></li><li><code>slave</code>执行接收到的命令，保持与<code>master</code>之间的同步</li></ul><h5 id="增量同步"><a href="#增量同步" class="headerlink" title="增量同步"></a>增量同步</h5><img src="/img/微服务面试/1.4.png" alt="image-20240824173308152" style="zoom:67%;" /><ul><li><p>repl_baklog原理</p><p>全量同步时的<code>repl_baklog</code>文件了。这个文件是一个固定大小的数组，只不过数组是环形，也就是说<strong>角标到达数组末尾后，会再次从0开始读写</strong>，这样数组头部的数据就会被覆盖</p><img src="/img/微服务面试/1.5.png" alt="image-20240824173445867" style="zoom:50%;" /><p>可以从以下几个方面来<strong>优化Redis主从就集群</strong>：</p><ul><li>在master中配置<code>repl-diskless-sync  yes</code>启用无磁盘复制，避免全量同步时的磁盘IO。</li><li>Redis单节点上的内存占用不要太大，减少RDB导致的过多磁盘IO</li><li>适当提高<code>repl_baklog</code>的大小，发现slave宕机时尽快实现故障恢复，尽可能避免全量同步</li><li>限制一个master上的slave节点数量，如果实在是太多slave，则可以采用<code>主-从-从</code>链式结构，减少master压力</li></ul></li></ul><p><strong>简述全量同步和增量同步区别？</strong></p><ul><li>全量同步：master将完整内存数据生成RDB，发送RDB到slave。后续命令则记录在repl_baklog，逐个发送给slave。</li><li>增量同步：slave提交自己的offset到master，master获取repl_baklog中从offset之后的命令给slave</li></ul><p><strong>什么时候执行全量同步？</strong></p><ul><li>slave节点第一次连接master节点时</li><li>slave节点断开时间太久，repl_baklog中的offset已经被覆盖时</li></ul><p><strong>什么时候执行增量同步？</strong></p><ul><li>slave节点断开又恢复，并且在<code>repl_baklog</code>中能找到offset时</li></ul><h4 id="Redis哨兵（Sentinel）"><a href="#Redis哨兵（Sentinel）" class="headerlink" title="Redis哨兵（Sentinel）"></a>Redis哨兵（Sentinel）</h4><h5 id="哨兵（Sentinel）工作原理"><a href="#哨兵（Sentinel）工作原理" class="headerlink" title="哨兵（Sentinel）工作原理"></a>哨兵（Sentinel）工作原理</h5><ul><li><p>哨兵（Sentinel）的<strong>作用</strong>如下：</p><ul><li><p><strong>状态监控</strong>：<code>Sentinel</code> 会不断检查您的<code>master</code>和<code>slave</code>是否按预期工作</p></li><li><p><strong>故障恢复（failover）</strong>：如果<code>master</code>故障，<code>Sentinel</code>会将一个<code>slave</code>提升为<code>master</code>。当故障实例恢复后会成为<code>slave</code></p></li><li><p><strong>状态通知</strong>：<code>Sentinel</code>充当<code>Redis</code>客户端的服务发现来源，当集群发生<code>failover</code>时，会将最新集群信息推送给<code>Redis</code>的客户端</p></li></ul></li><li><p>Sentinel如何判断<strong>一个redis实例是否健康</strong>？</p><ul><li><p>每隔一秒发送一个ping命令，如果超过一定时间没有相向则认为是主观下线</p></li><li><p>如果大多数sentinel都认为实例主观下线，则判定服务下线</p></li></ul></li><li><p>故障转移步骤有哪些</p><ul><li>首先选定slave作为新的master，执行slaveof no one</li><li>然后让所有的节点执行slaveof新master</li><li>修改故障节点，执行slaveof新master</li></ul></li></ul><h5 id="搭建哨兵集群"><a href="#搭建哨兵集群" class="headerlink" title="搭建哨兵集群"></a>搭建哨兵集群</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sentinel announce-ip <span class="string">&quot;192.168.150.101&quot;</span></span><br><span class="line">sentinel monitor hmaster 192.168.150.101 7001 2</span><br><span class="line">sentinel down-after-milliseconds hmaster 5000</span><br><span class="line">sentinel failover-timeout hmaster 60000</span><br></pre></td></tr></table></figure><ul><li><code>sentinel announce-ip &quot;192.168.150.101&quot;</code>：声明当前sentinel的ip</li><li><code>sentinel monitor hmaster 192.168.150.101 7001 2</code>：指定集群的主节点信息 <ul><li><code>hmaster</code>：主节点名称，自定义，任意写</li><li><code>192.168.150.101 7001</code>：主节点的ip和端口</li><li><code>2</code>：认定<code>master</code>下线时的<code>quorum</code>值</li></ul></li><li><code>sentinel down-after-milliseconds hmaster 5000</code>：声明master节点超时多久后被标记下线</li><li><code>sentinel failover-timeout hmaster 60000</code>：在第一次故障转移失败后多久再次重试</li></ul><p>sentinel<strong>选举leader的依据</strong>是什么？</p><ul><li>票数超过sentinel节点数量1半</li><li>票数超过quorum数量</li><li>一般情况下最先发起failover的节点会当选</li></ul><p>sentinel<strong>从slave中选取master的依据</strong>是什么？</p><ul><li>首先会判断slave节点与master节点断开时间长短，如果超过<code>down-after-milliseconds`` * 10</code>则会排除该slave节点</li><li>然后判断slave节点的<code>slave-priority</code>值，越小优先级越高，如果是0则永不参与选举（默认都是1）。</li><li>如果<code>slave-prority</code>一样，则判断slave节点的<code>offset</code>值，越大说明数据越新，优先级越高</li><li>最后是判断slave节点的<code>run_id</code>大小，越小优先级越高（<code>通过info server可以查看run_id</code>）。</li></ul><h4 id="Redis分片集群"><a href="#Redis分片集群" class="headerlink" title="Redis分片集群"></a>Redis分片集群</h4><img src="/img/微服务面试/1.6.png" alt="image-20240826144348383" style="zoom: 50%;" /><h5 id="集群配置"><a href="#集群配置" class="headerlink" title="集群配置"></a>集群配置</h5><ul><li><pre><code class="bash">port 7000cluster-enabled yescluster-config-file nodes.confcluster-node-timeout 5000appendonly yes<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  其中有3个我们没见过的参数：</span><br><span class="line"></span><br><span class="line">  - `cluster-enabled`：是否开启集群模式</span><br><span class="line">  - `cluster-config-file`：集群模式的配置文件名称，无需手动创建，由集群自动维护</span><br><span class="line">  - `cluster-node-timeout`：集群中节点之间心跳超时时间</span><br><span class="line"></span><br><span class="line">- ```bash</span><br><span class="line">  # 进入任意节点容器</span><br><span class="line">  docker exec -it r1 bash</span><br><span class="line">  # 然后，执行命令</span><br><span class="line">  redis-cli --cluster create --cluster-replicas 1 \</span><br><span class="line">  192.168.150.101:7001 192.168.150.101:7002 192.168.150.101:7003 \</span><br><span class="line">  192.168.150.101:7004 192.168.150.101:7005 192.168.150.101:7006</span><br></pre></td></tr></table></figure>命令说明：- `redis-cli --cluster`：代表集群操作命令- `create`：代表是创建集群- `--cluster-replicas 1` ：指定集群中每个`master`的副本个数为1  - 此时`节点总数 ÷ (replicas + 1)` 得到的就是`master`的数量`n`。因此节点列表中的前`n`个节点就是`master`，其它节点都是`slave`节点，随机分配到不同`master`</code></pre></li><li><p>Redis分片集群如何判断某个key应该在哪个实例？</p><ul><li>将16384个插槽分配到不同的实例</li><li>根据key计算哈希值，对16384取余</li><li>余数作为插槽，寻找插槽所在实例即可</li></ul></li></ul><h4 id="Redis数据结构"><a href="#Redis数据结构" class="headerlink" title="Redis数据结构"></a>Redis数据结构</h4><ul><li><p>我们常用的<strong>Redis数据类型</strong>有5种，分别是：</p><ul><li>String</li><li>List</li><li>Set</li><li>SortedSet</li><li>Hash</li></ul></li><li><p>RedisObject</p><ul><li><p><img src="/img/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%9D%A2%E8%AF%95/1.7.png" alt="image-20240826152116160"></p></li><li><p>Redis中的5种不同的数据类型采用的底层数据结构和编码方式如下：</p><table><thead><tr><th align="center"><strong>数据类型</strong></th><th align="center"><strong>编码方式</strong></th></tr></thead><tbody><tr><td align="center">STRING</td><td align="center"><code>int</code>、<code>embstr</code>、<code>raw</code></td></tr><tr><td align="center">LIST</td><td align="center"><code>LinkedList和ZipList</code>(3.2以前)、<code>QuickList</code>（3.2以后）</td></tr><tr><td align="center">SET</td><td align="center"><code>intset</code>、<code>HT</code></td></tr><tr><td align="center">ZSET</td><td align="center"><code>ZipList</code>（7.0以前）、<code>Listpack</code>（7.0以后）、<code>HT</code>、<code>SkipList</code></td></tr><tr><td align="center">HASH</td><td align="center"><code>ZipList</code>（7.0以前）、<code>Listpack</code>（7.0以后）、<code>HT</code></td></tr></tbody></table></li></ul></li><li><p>SkipList</p><ul><li>SkipList（跳表）首先是链表，但与传统链表相比有几点差异：<ul><li>元素按照升序排列存储</li><li>节点可能包含多个指针，指针跨度不同。</li></ul></li><li>SkipList的特点<ul><li>跳跃表是一个有序的双向链表</li><li>每个节点都可以包含多层指针，层数是1到32之间的随机数</li><li>不同层指针到下一个节点的跨度不同，层级越高，跨度越大</li><li>增删改查效率与红黑树基本一致，实现却更为简单。但空间复杂度高</li></ul></li></ul></li><li><p>SortedSet</p><p><strong>面试题</strong>：Redis的<code>SortedSet</code>底层的数据结构是怎样的？</p><p><strong>答</strong>：SortedSet是有序集合，底层的存储的每个数据都包含element和score两个值。score是得分，element则是字符串值。SortedSet会根据每个element的score值排序，形成有序集合。</p><p>它支持的操作很多，比如：</p><ul><li>根据element查询score值</li><li>按照score值升序或降序查询element</li></ul><p>要实现根据element查询对应的score值，就必须实现element与score之间的键值映射。SortedSet底层是基于<strong>HashTable</strong>来实现的。</p><p>要实现对score值排序，并且查询效率还高，就需要有一种高效的有序数据结构，SortedSet是基于<strong>跳表</strong>实现的。</p><p>加分项：因为SortedSet底层需要用到两种数据结构，对内存占用比较高。因此Redis底层会对SortedSet中的元素大小做判断。如果<strong>元素大小小于128</strong>且<strong>每个元素都小于64字节</strong>，SortedSet底层会采用<strong>ZipList</strong>，也就是<strong>压缩列</strong>表来代替<strong>HashTable</strong>和<strong>SkipList</strong></p><p>不过，<code>ZipList</code>存在连锁更新问题，因此而在Redis7.0版本以后，<code>ZipList</code>又被替换为<strong>Listpack</strong>（紧凑列表）。</p></li></ul><h4 id="Redis内存回收"><a href="#Redis内存回收" class="headerlink" title="Redis内存回收"></a>Redis内存回收</h4><h5 id="过期KEY处理"><a href="#过期KEY处理" class="headerlink" title="过期KEY处理"></a>过期KEY处理</h5><ul><li><p>RedisKey的TTL记录方式：再RedisDB中通过一个哈希表记录每个Key的到期时间</p></li><li><p>Redis的过期KEY删除策略有两种：</p><ul><li>惰性删除：Redis会在每次访问KEY的时候判断当前KEY有没有设置过期时间，如果有，过期时间是否已经到期，判断到期后进行删除</li><li>周期删除：顾明思议是通过一个定时任务，周期性的抽样部分过期的key，然后执行删除。<ul><li>执行周期有两种：<ul><li><strong>SLOW模式：</strong>Redis会设置一个定时任务<code>serverCron()</code>，按照<code>server.hz</code>的频率来执行过期key清理</li><li><strong>FAST模式：</strong>Redis的每个事件循环前执行过期key清理（事件循环就是NIO事件处理的循环）。</li></ul></li></ul></li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
