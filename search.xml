<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JavaSE基础加强</title>
      <link href="/2024/09/07/JavaSE%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA/"/>
      <url>/2024/09/07/JavaSE%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="JavaSE基础加强"><a href="#JavaSE基础加强" class="headerlink" title="JavaSE基础加强"></a>JavaSE基础加强</h2><h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><h5 id="认识异常"><a href="#认识异常" class="headerlink" title="认识异常"></a>认识异常</h5><ul><li>Exception：叫异常，代表程序出现的问题。<ul><li>运行时异常：<strong>RunTimeException</strong>及其子类，编译阶段不会出现错误提醒，运行时出现的异常（如：数组索引越界异常）</li><li>编译时异常：编译阶段就会出现错误提醒的。（如：日期解析异常）</li></ul></li><li>异常的基本处理<ul><li>抛出异常（<strong>throws</strong>）<ul><li>在方法上使用<strong>throws</strong>关键字，可以将方法内部出现的异常抛出给调用则处理</li></ul></li><li>捕获异常（<strong>try…catch</strong>）<ul><li>直接捕获程序出现的异常</li></ul></li></ul></li><li>异常的作用<ul><li>定位程序bug的关键信息<ul><li>可以作为方法内部一种特殊返回值通知上层调用者，方法的执行问题</li></ul></li></ul></li></ul><h5 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h5><ul><li>Java无法为全部的问题提供异常类代表，如果企业自己的某种异常，想通过异常来表达，以便于异常来管理问题，那就需要自己来定义异常类。</li><li>自定义运行时异常</li><li>自定义编译时异常<ul><li>定义一个异常类继承Exception。重写构造器。通过throw new异常类（xxx）创建异常对象并抛出。</li></ul></li></ul><h5 id="异常的处理方案"><a href="#异常的处理方案" class="headerlink" title="异常的处理方案"></a>异常的处理方案</h5><ul><li>异常的处理方案 1：底层异常层层抛出，最外层捕获异常，记录异常，响应合适的信息给客户观看</li><li>常处理方案 2：捕获异常对象，尝试重新修复</li></ul><h4 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h4><h5 id="认识泛型"><a href="#认识泛型" class="headerlink" title="认识泛型"></a>认识泛型</h5><ul><li>定义类、接口、方法，同时声明一个或多个类型变量。称为泛型类、泛型接口、泛型方法、都统称为泛型。</li><li>作用：泛型提供了在编译阶段约束所能操作的数据类型，并自动进行检查的能力这样可以避免强制类型转换，及其可能出现的异常。   </li><li>泛型的本质：具体的参数类型传给类型变量</li></ul><h5 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h5><ul><li>泛型类是在类的定义中使用类型参数的类。这些类型参数可以在<strong>类的成员变量</strong>、<strong>方法参数</strong>和<strong>返回值</strong>等位置使用，使得类可以在不同的场景下处理不同类型的数据，提高了代码的复用性和类型安全性。</li></ul><h5 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h5><ul><li>泛型接口是在接口定义中包含类型参数的接口。通过使用泛型接口，可以使实现该接口的类能够灵活地处理不同类型的数据，同时在编译阶段保证类型安全。</li><li><strong>优势</strong><ol><li><strong>增强代码复用性</strong>：与非泛型接口相比，泛型接口可以被更多不同类型相关的类实现，避免了重复编写类似功能但针对不同数据类型的接口。</li><li><strong>提高类型安全性</strong>：在编译期间确保类型的一致性，减少了因类型不匹配导致的错误。例如，如果接口定义了操作<code>T</code>类型数据的方法，实现类就必须遵循这个类型约束进行操作，避免了在运行时出现意外的类型转换问题。</li></ol></li></ul><h5 id="泛型方法、通配符、上下限"><a href="#泛型方法、通配符、上下限" class="headerlink" title="泛型方法、通配符、上下限"></a>泛型方法、通配符、上下限</h5><ul><li><p><strong>泛型方法</strong>：泛型方法是在方法声明中使用类型参数的方法。这种方法可以在不同的调用中接受不同类型的参数，而不需要为每种类型都定义一个单独的方法。</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">public &lt;T&gt; T genericMethod(T parameter) <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// 方法体</span></span><br><span class="line">    return parameter;</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>在上述代码中，<code>&lt;T&gt;</code>放在方法修饰符后面，表示这是一个泛型方法，<code>T</code>是类型参数</p></li><li><p><strong>通配符</strong>：就是“？”，可以在“使用泛型”的时候代表一切类型；E T K V实在定义泛型的时候使用</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">public static void printList(List&lt;?&gt; list) <span class="punctuation">&#123;</span></span><br><span class="line">    for (Object element <span class="punctuation">:</span> list) <span class="punctuation">&#123;</span></span><br><span class="line">        System.out.println(element);</span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>上（下）界通配符的使用</strong></p><ol><li><strong>上界通配符</strong>：使用<code>? extends T</code>表示，例如<code>List&lt;? extends Number&gt;</code>。这意味着<code>List</code>中的元素类型是<code>Number</code>或者<code>Number</code>的子类。可以从这样的集合中安全地读取元素并将其赋值给<code>Number</code>或<code>Number</code>的父类类型的变量。</li><li><strong>下界通配符</strong>：使用<code>? super T</code>表示，例如<code>List&lt;? super Integer&gt;</code>。这表示<code>List</code>中的元素类型是<code>Integer</code>或者<code>Integer</code>的父类。可以向这样的集合中添加<code>Integer</code>或者<code>Integer</code>子类的元素。</li></ol><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">public static double sumOfList(List&lt;? extends Number&gt; list) <span class="punctuation">&#123;</span></span><br><span class="line">    double sum = <span class="number">0.0</span>;</span><br><span class="line">    for (Number number <span class="punctuation">:</span> list) <span class="punctuation">&#123;</span></span><br><span class="line">        sum += number.doubleValue();</span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">    return sum;</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="泛型支持的类型"><a href="#泛型支持的类型" class="headerlink" title="泛型支持的类型"></a>泛型支持的类型</h5><ul><li>泛型支持的类型：泛型和集合不支持基本数据类型，只能支持对象类型（引用数据类型）</li><li>泛型擦除：泛型工作在编译阶段，等编译后泛型就没用了，所以在编译后都会被擦除。所有类型会恢复成object类型</li><li>包装类：把基本数据类型的数据包装成对象的类型。</li><li>自动装箱&#x2F;拆箱：基本数据类型与包装类型之间可以自动转换</li></ul><h4 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h4><p>集合是一种容器，用来装数据的，类似于数组，但集合的大小可变。集合分为单列集合Collection（只包含一个值）和双列集合Map（包含有两个值，是key-value键值对）</p><h5 id="Collection的功能"><a href="#Collection的功能" class="headerlink" title="Collection的功能"></a>Collection的功能</h5><ul><li><p>常用功能</p><table><thead><tr><th align="center">collection提供的通用集合功能</th><th align="center">代码示例</th></tr></thead><tbody><tr><td align="center">添加元素</td><td align="center">list.add(“1”)</td></tr><tr><td align="center">获取集合的元素个数</td><td align="center">list.size()</td></tr><tr><td align="center">删除集合元素</td><td align="center">list.remove(“1”)</td></tr><tr><td align="center">判断集合是否存在某个数据</td><td align="center">list.contains(“1”)</td></tr><tr><td align="center">把集合换成数组</td><td align="center">list.toArray()</td></tr><tr><td align="center">判断集合是否为空</td><td align="center">list.isEmpty()</td></tr><tr><td align="center">清空集合</td><td align="center">list.clear()</td></tr></tbody></table></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> /img/JavaSE基础加强/top_img.png </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务面试</title>
      <link href="/2024/09/05/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%9D%A2%E8%AF%95/"/>
      <url>/2024/09/05/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h2 id="微服务面试"><a href="#微服务面试" class="headerlink" title="微服务面试"></a>微服务面试</h2><h4 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h4><ul><li><p><strong>分布式事务</strong>，就是指不是在单个服务或单个数据库架构下，产生的事务，例如：</p><ul><li><p>跨数据源的分布式事务</p></li><li><p>跨服务的分布式事务</p></li><li><p>综合情况</p></li></ul></li></ul><h5 id="CAP和BASE"><a href="#CAP和BASE" class="headerlink" title="CAP和BASE"></a>CAP和BASE</h5><ul><li><p>分布式系统有三个指标：<strong>C</strong>onsistency（一致性），<strong>A</strong>vailability（可用性），<strong>P</strong>artition tolerance （分区容错性）它们的第一个字母分别是 <code>C</code>、<code>A</code>、<code>P</code>。Eric Brewer认为任何分布式系统架构方案都不可能同时满足这3个目标，这个结论就叫做 CAP 定理。</p></li><li><p>CAP矛盾</p><p>在分布式系统中，网络不能100%保证畅通，也就是说网络分区的情况一定会存在。而我们的系统必须要持续运行，对外提供服务。所以分区容错性（<code>P</code>）是硬性指标，所有分布式系统都要满足。而在设计分布式系统时要取舍的就是一致性（<code>C</code>）和可用性（<code>A</code>）了。</p><img src="/img/微服务面试/1.1.png" alt="image-20240902161445922" style="zoom:67%;" /><p>由于网络故障，当我们把数据写入node01时，可以与node02完成数据同步，但是无法同步给node03。现在有两种选择：</p><ul><li>允许用户任意读写，保证可用性。但由于node03无法完成同步，就会出现数据不一致的情况。满足AP</li><li>不允许用户写，可以读，直到网络恢复，分区消失。这样就确保了一致性，但牺牲了可用性。满足CP</li></ul><p>可见，在分布式系统中，<code>A</code>和<code>C</code>之间只能满足一个。</p></li><li><p>BASE理论：<strong>B</strong>asically <strong>A</strong>vailable <strong>（</strong>基本可用<strong>）</strong>：分布式系统在出现故障时，允许损失部分可用性，即保证核心可用。<strong>S</strong>oft State<strong>（</strong>软状态<strong>）：</strong>在一定时间内，允许出现中间状态，比如临时的不一致状态。<strong>Ev</strong>entually Consistent<strong>（</strong>最终一致性<strong>）</strong>：虽然无法保证强一致性，但是在软状态结束后，最终达到数据一致。以上就是BASE理论。<strong>解决分布式事务的思想也是这样，有两个方向：</strong></p><ul><li><strong>AP思想</strong>：各个子事务分别执行和提交，无需锁定数据。允许出现结果不一致，然后采用弥补措施恢复，实现最终一致即可。例如<code>AT</code>模式就是如此</li><li><strong>CP思想</strong>：各个子事务执行后不要提交，而是等待彼此结果，然后同时提交或回滚。在这个过程中锁定资源，不允许其它人访问，数据处于不可用状态，但能保证一致性。例如<code>XA</code>模式</li></ul></li></ul><h5 id="AT模式的脏写字问题"><a href="#AT模式的脏写字问题" class="headerlink" title="AT模式的脏写字问题"></a>AT模式的脏写字问题</h5><ul><li><p>AT模式</p><ul><li><p>第一阶段：记录数据快照，执行并提交事务</p><img src="/img/微服务面试/1.2.png" alt="image-20240902164350512" style="zoom:67%;" /></li><li><p>第二阶段：根据结果判断是否所有的分支事务完成</p><ul><li>如果每一个分支事务都成功，则事务已经结束（因为阶段一已经提交），因此删除阶段一的快照即可</li><li>如果有任意分支事务失败，则需要根据快照恢复到更新前数据。然后删除快照</li></ul><img src="/img/微服务面试/1.3.png" alt="image-20240902164414156" style="zoom:67%;" /></li></ul></li><li><p>以上AT模式通常情况不会出现问题，但是在极端情况中，特别是多线程并发访问AT模式的分布式事务时，有可能出现脏写问题。如图，解决方法是引入全局锁，释放DB锁之前，先拿到全局锁。避免同一时刻有另外一个事务来操作当前数据。</p><img src="/img/微服务面试/1.4.png" alt="image-20240902165056011" style="zoom:67%;" /></li></ul><h5 id="TCC模式"><a href="#TCC模式" class="headerlink" title="TCC模式"></a>TCC模式</h5><ul><li><p>TCC模式与AT模式非常相似，每阶段都是独立事务，不同的是TCC通过人工编码来实现数据恢复。需要实现三个方法：</p><ul><li><code>try</code>：资源的检测和预留； </li><li><code>confirm</code>：完成资源操作业务；要求 <code>try</code> 成功 <code>confirm</code> 一定要能成功。 </li><li><code>cancel</code>：预留资源释放，可以理解为try的反向操作。</li></ul></li><li><p>TCC的工作模型图</p><img src="/img/微服务面试/1.5.png" alt="image-20240904173630434" style="zoom: 80%;" /></li><li><p>TCC的优点是什么？</p><ul><li>一阶段完成直接提交事务，释放数据库资源，性能好</li><li>相比AT模型，无需生成快照，无需使用全局锁，性能最强</li><li>不依赖数据库事务，而是依赖补偿操作，可以用于非事务型数据库</li></ul></li><li><p>TCC的缺点是什么？</p><ul><li>有代码侵入，需要人为编写try、Confirm和Cancel接口，太麻烦</li><li>软状态，事务是最终一致</li><li>需要考虑Confirm和Cancel的失败情况，做好幂等处理、事务悬挂和空回滚处理</li></ul></li></ul><h5 id="最大努力通知"><a href="#最大努力通知" class="headerlink" title="最大努力通知"></a>最大努力通知</h5><p>最大努力通知是一种最终一致性的分布式事务解决方案。顾明思议，就是通过消息通知的方式来通知事务参与者完成业务执行，如果执行失败会多次通知。无需任何分布式事务组件介入。</p><h4 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h4><h5 id="环境隔离"><a href="#环境隔离" class="headerlink" title="环境隔离"></a>环境隔离</h5><ul><li><p>企业实际开发中，往往会搭建多个运行环境，例如：</p><ul><li>开发环境</li><li>测试环境</li><li>预发布环境</li><li>生产环境</li></ul><p>这些不同环境之间的服务和数据之间需要隔离。因此，Nacos提供了基于<code>namespace</code>的环境隔离功能。</p></li><li><p>创建namespace</p><p>nacos提供了一个默认的<code>namespace</code>，叫做<code>public</code>：</p><img src="/img/微服务面试/1.6.png" alt="image-20240904175832569" style="zoom:80%;" /><img src="/img/微服务面试/1.7.png" alt="image-20240904175900021" style="zoom:80%;" /><p>添加完成后，可以在页面看到我们新建的<code>namespace</code>，并且Nacos为我们自动生成了一个命名空间id：</p><img src="/img/微服务面试/1.8.png" alt="image-20240904175948967" style="zoom:80%;" /><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">item-service</span> <span class="comment"># 服务名称</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span> <span class="comment"># nacos地址</span></span><br><span class="line">      <span class="attr">discovery:</span> <span class="comment"># 服务发现配置</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">8c468c63-b650-48da-a632-311c75e6d235</span> <span class="comment"># 设置namespace，必须用id</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="分级模型"><a href="#分级模型" class="headerlink" title="分级模型"></a>分级模型</h5><ul><li><p>Nacos中提供了集群（<code>cluster</code>）的概念，来对应不同机房。也就是说，一个服务（<code>service</code>）下可以有很多集群（<code>cluster</code>），而一个集群（<code>cluster</code>）中下又可以包含很多实例（<code>instance</code>）</p></li><li><p>因此，结合学习的<code>namespace</code>命名空间的知识，任何一个微服务的实例在注册到Nacos时，都会生成以下几个信息，用来确认当前实例的身份，从外到内依次是：</p><ul><li>namespace：命名空间</li><li>group：分组</li><li>service：服务名</li><li>cluster：集群</li><li>instance：实例，包含ip和端口</li></ul><p>这就是nacos中的服务分级模型。</p><p><img src="/img/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%9D%A2%E8%AF%95/1.9.png" alt="image-20240904181419276"></p></li></ul><h5 id="Eureka与Nacos"><a href="#Eureka与Nacos" class="headerlink" title="Eureka与Nacos"></a>Eureka与Nacos</h5><ul><li><p>Eureka是Netflix公司开源的一个服务注册中心组件，早期版本的SpringCloud都是使用Eureka作为注册中心。由于Eureka和Nacos的starter中提供的功能都是基于SpringCloudCommon规范，因此两者使用起来差别不大。</p></li><li><p>微服务引入Eureka的方式也极其简单，分两步：</p><ul><li>引入<code>eureka-client</code>依赖</li><li>配置<code>eureka</code>地址</li></ul></li><li><p><img src="/img/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%9D%A2%E8%AF%95/1.10.png" alt="image-20240904190608205"></p><p>综上，Eureka和Nacos的<strong>相似点</strong>有：</p><ul><li>都支持服务注册发现功能</li><li>都有基于心跳的健康监测功能</li><li>都支持集群，集群间数据同步默认是AP模式，即最全高可用性</li><li>Eureka和Nacos都支持集群，而且默认都是AP模式</li></ul><p>Eureka和Nacos的<strong>区别</strong>有：</p><ul><li>Eureka的心跳是<strong>30秒一次</strong>，Nacos则是<strong>5秒一次</strong></li><li>Eureka如果<strong>90秒未收到心跳</strong>，则认为服务疑似故障，<strong>可能</strong>被剔除。Nacos中则是<strong>15秒超时，30秒剔除</strong>。</li><li>Eureka<strong>每隔60秒</strong>执行一次服务检测和清理任务；Nacos是每隔5秒执行一次。</li><li>Eureka只能<strong>等微服务自己每隔30秒更新</strong>一次服务列表；Nacos即有<strong>定时更新</strong>，也有在服务变更时的广播推送</li><li>Eureka<strong>仅有注册中心功能</strong>，而Nacos同时<strong>支持注册中心、配置管理</strong></li></ul></li></ul><h4 id="远程调用"><a href="#远程调用" class="headerlink" title="远程调用"></a>远程调用</h4><h5 id="负载均衡的原理"><a href="#负载均衡的原理" class="headerlink" title="负载均衡的原理"></a>负载均衡的原理</h5><ul><li><p>根据之前的分析，我们会发现Spring在整合OpenFeign的时候，实现了<code>org.springframework.cloud.openfeign.loadbalancer.FeignBlockingLoadBalancerClient</code>类，其中定义了OpenFeign发起远程调用的核心流程。也就是四步：</p><ul><li>获取请求中的<code>serviceId</code></li><li>根据<code>serviceId</code>负载均衡，找出一个可用的服务实例</li><li>利用服务实例的<code>ip</code>和<code>port</code>信息重构url</li><li>向真正的url发起请求</li></ul></li><li><p>具体的负载均衡则是不是由<code>OpenFeign</code>组件负责。而是分成了<strong>负载均衡的接口规范</strong>，以及<strong>负载均衡的具体实现</strong>两部分。</p><p>负载均衡的接口规范是定义在<code>Spring-Cloud-Common</code>模块中，包含下面的接口：</p><ul><li><p><code>LoadBalancerClient</code>：负载均衡客户端，职责是根据serviceId最终负载均衡，选出一个服务实例</p></li><li><p><code>ReactiveLoadBalancer</code>：负载均衡器，负责具体的负载均衡算法</p><img src="/img/微服务面试/1.11.png" alt="image-20240905100118186" style="zoom:80%;" /></li></ul></li></ul><h4 id="服务保护"><a href="#服务保护" class="headerlink" title="服务保护"></a>服务保护</h4><h5 id="线程隔离"><a href="#线程隔离" class="headerlink" title="线程隔离"></a>线程隔离</h5><ul><li>线程隔离有两种方式实现：<ul><li><strong>线程池隔离</strong>：给每个服务调用业务分配一个线程池，利用线程池本身实现隔离效果</li><li><strong>信号量隔离</strong>：不创建线程池，而是计数器模式，记录业务使用的线程数量，达到信号量上限时，禁止新的请求</li></ul></li><li>线程池隔离<ul><li>优点：支持主动超时，支持异步调用</li><li>缺点：线程的额外开销比较大</li><li>场景：低扇出</li></ul></li><li>信号量隔离<ul><li>优点：轻量级，无额外开销</li><li>缺点：不支持主动超时，不支持异步调用</li><li>场景：高频调用，高扇出</li></ul></li></ul><h5 id="滑动窗口算法"><a href="#滑动窗口算法" class="headerlink" title="滑动窗口算法"></a>滑动窗口算法</h5><ul><li><p>在熔断功能中，需要统计异常请求或慢请求比例，也就是计数。在限流的时候，要统计每秒钟的QPS，同样是计数。可见计数算法在熔断限流中的应用非常多。sentinel中采用的计数器算法就是<strong>滑动窗口计数算法</strong>。</p></li><li><p>固定时间窗口算法中窗口有很多，其跨度和位置是与时间区间绑定，因此是很多固定不动的窗口。而滑动时间窗口算法中只包含1个固定跨度的窗口，但窗口是可移动动的，与时间区间无关。</p><p>具体规则如下：</p><ul><li>窗口时间跨度<code>Interval</code>大小固定，例如1秒</li><li>时间区间跨度为<code>Interval / n</code> ，例如n&#x3D;2，则时间区间跨度为500ms</li><li>窗口会随着当前请求所在时间<code>currentTime</code>移动，窗口范围从<code>currentTime-Interval</code>时刻之后的第一个时区开始，到<code>currentTime</code>所在时区结束。</li><li><img src="/img/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%9D%A2%E8%AF%95/1.12.png" alt="image-20240905102550019"></li></ul></li></ul><h5 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h5><ul><li><p>简单来说就是请求到达后不是直接处理，而是先放入一个队列。而后以固定的速率从队列中取出并处理请求。之所以叫漏桶算法，就是把请求看做水，队列看做是一个漏了的桶</p><img src="/img/微服务面试/1.13.png" alt="image-20240905103549402" style="zoom: 67%;" /></li><li><p>说明：</p><ul><li>将每个请求视作”水滴”放入”漏桶”进行存储；</li><li>“漏桶”以固定速率向外”漏”出请求来执行，如果”漏桶”空了则停止”漏水”；</li><li>如果”漏桶”满了则多余的”水滴”会被直接丢弃。</li></ul></li><li><p>漏桶的优势就是<strong>流量整型</strong>，桶就像是一个大坝，请求就是水。并发量不断波动，就如图水流时大时小，但都会被大坝拦住。而后大坝按照固定的速度放水，避免下游被洪水淹没。因此，不管并发量如何波动，经过漏桶处理后的请求一定是相对平滑的曲线。</p></li></ul><h5 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h5><ul><li><p>Sentinel中的热点参数限流正是基于令牌桶算法实现的。其基本思路如图：</p><img src="/img/微服务面试/1.14.png" alt="image-20240905103748753" style="zoom:67%;" /></li><li><p>说明：</p><ul><li>以固定的速率生成令牌，存入令牌桶中，如果令牌桶满了以后，多余令牌丢弃</li><li>请求进入后，必须先尝试从桶中获取令牌，获取到令牌后才可以被处理</li><li>如果令牌桶中没有令牌，则请求等待或丢弃</li></ul></li><li><p>基于令牌桶算法，每秒产生的令牌数量基本就是QPS上限。</p><p>当然也有例外情况，例如：</p><ul><li>某一秒令牌桶中产生了很多令牌，达到令牌桶上限N，缓存在令牌桶中，但是这一秒没有请求进入。</li><li>下一秒的前半秒涌入了超过2N个请求，之前缓存的令牌桶的令牌耗尽，同时这一秒又生成了N个令牌，于是总共放行了2N个请求。超出了我们设定的QPS阈值。</li></ul><p>因此，在使用令牌桶算法时，尽量不要将令牌上限设定到服务能承受的QPS上限。而是预留一定的波动空间，这样我们才能应对突发流量。</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis面试</title>
      <link href="/2024/08/02/Redis%E9%9D%A2%E8%AF%95/"/>
      <url>/2024/08/02/Redis%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis面试"><a href="#Redis面试" class="headerlink" title="Redis面试"></a>Redis面试</h2><h4 id="Redis主从"><a href="#Redis主从" class="headerlink" title="Redis主从"></a>Redis主从</h4><img src="/img/Redis面试/1.1.png" alt="image-20240824154926853" style="zoom: 67%;" /><p>如图所示，集群中有一个master节点、两个slave节点（现在叫replica）。当我们通过Redis的Java客户端访问主从集群时，应该做好路由：</p><ul><li>如果是<strong>写操作</strong>，应该访问master节点，master会自动将数据同步给两个slave节点</li><li>如果是<strong>读操作</strong>，建议访问各个slave节点，从而分担并发压力</li></ul><p>创建、启动Redis实例后，并不会自动形成<strong>主从关系</strong>，需要通过命令来配置关系</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Redis5.0以前</span></span><br><span class="line">slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br><span class="line"><span class="comment"># Redis5.0以后</span></span><br><span class="line">replicaof &lt;masterip&gt; &lt;masterport&gt;</span><br></pre></td></tr></table></figure><p>有临时和永久两种模式：</p><ul><li>永久生效：在redis.conf文件中利用<code>slaveof</code>命令指定<code>master</code>节点</li><li>临时生效：直接利用redis-cli控制台输入<code>slaveof</code>命令，指定<code>master</code>节点</li></ul><p><strong>主从同步原理</strong></p><img src="/img/Redis面试/1.2.png" alt="image-20240824170605490" style="zoom:67%;" /><h5 id="全量同步"><a href="#全量同步" class="headerlink" title="全量同步"></a><strong>全量同步</strong></h5><img src="/img/Redis面试/1.3.png" alt="image-20240824172657901" style="zoom:67%;" /><p>完整流程描述：</p><ul><li><code>slave</code>节点请求增量同步</li><li><code>master</code>节点判断<code>replid</code>，发现不一致，拒绝增量同步</li><li><code>master</code>将完整内存数据生成<code>RDB</code>，发送<code>RDB</code>到<code>slave</code></li><li><code>slave</code>清空本地数据，加载<code>master</code>的<code>RDB</code></li><li><code>master</code>将<code>RDB</code>期间的命令记录在<code>repl_baklog</code>，并持续将log中的命令发送给<code>slave</code></li><li><code>slave</code>执行接收到的命令，保持与<code>master</code>之间的同步</li></ul><h5 id="增量同步"><a href="#增量同步" class="headerlink" title="增量同步"></a>增量同步</h5><img src="/img/Redis面试/1.4.png" alt="image-20240824173308152" style="zoom:67%;" /><ul><li><p>repl_baklog原理</p><p>全量同步时的<code>repl_baklog</code>文件了。这个文件是一个固定大小的数组，只不过数组是环形，也就是说<strong>角标到达数组末尾后，会再次从0开始读写</strong>，这样数组头部的数据就会被覆盖</p><img src="/img/Redis面试/1.5.png" alt="image-20240824173445867" style="zoom:50%;" /><p>可以从以下几个方面来<strong>优化Redis主从就集群</strong>：</p><ul><li>在master中配置<code>repl-diskless-sync  yes</code>启用无磁盘复制，避免全量同步时的磁盘IO。</li><li>Redis单节点上的内存占用不要太大，减少RDB导致的过多磁盘IO</li><li>适当提高<code>repl_baklog</code>的大小，发现slave宕机时尽快实现故障恢复，尽可能避免全量同步</li><li>限制一个master上的slave节点数量，如果实在是太多slave，则可以采用<code>主-从-从</code>链式结构，减少master压力</li></ul></li></ul><p><strong>简述全量同步和增量同步区别？</strong></p><ul><li>全量同步：master将完整内存数据生成RDB，发送RDB到slave。后续命令则记录在repl_baklog，逐个发送给slave。</li><li>增量同步：slave提交自己的offset到master，master获取repl_baklog中从offset之后的命令给slave</li></ul><p><strong>什么时候执行全量同步？</strong></p><ul><li>slave节点第一次连接master节点时</li><li>slave节点断开时间太久，repl_baklog中的offset已经被覆盖时</li></ul><p><strong>什么时候执行增量同步？</strong></p><ul><li>slave节点断开又恢复，并且在<code>repl_baklog</code>中能找到offset时</li></ul><h4 id="Redis哨兵（Sentinel）"><a href="#Redis哨兵（Sentinel）" class="headerlink" title="Redis哨兵（Sentinel）"></a>Redis哨兵（Sentinel）</h4><h5 id="哨兵（Sentinel）工作原理"><a href="#哨兵（Sentinel）工作原理" class="headerlink" title="哨兵（Sentinel）工作原理"></a>哨兵（Sentinel）工作原理</h5><ul><li><p>哨兵（Sentinel）的<strong>作用</strong>如下：</p><ul><li><p><strong>状态监控</strong>：<code>Sentinel</code> 会不断检查您的<code>master</code>和<code>slave</code>是否按预期工作</p></li><li><p><strong>故障恢复（failover）</strong>：如果<code>master</code>故障，<code>Sentinel</code>会将一个<code>slave</code>提升为<code>master</code>。当故障实例恢复后会成为<code>slave</code></p></li><li><p><strong>状态通知</strong>：<code>Sentinel</code>充当<code>Redis</code>客户端的服务发现来源，当集群发生<code>failover</code>时，会将最新集群信息推送给<code>Redis</code>的客户端</p></li></ul></li><li><p>Sentinel如何判断<strong>一个redis实例是否健康</strong>？</p><ul><li><p>每隔一秒发送一个ping命令，如果超过一定时间没有相向则认为是主观下线</p></li><li><p>如果大多数sentinel都认为实例主观下线，则判定服务下线</p></li></ul></li><li><p>故障转移步骤有哪些</p><ul><li>首先选定slave作为新的master，执行slaveof no one</li><li>然后让所有的节点执行slaveof新master</li><li>修改故障节点，执行slaveof新master</li></ul></li></ul><h5 id="搭建哨兵集群"><a href="#搭建哨兵集群" class="headerlink" title="搭建哨兵集群"></a>搭建哨兵集群</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sentinel announce-ip <span class="string">&quot;192.168.150.101&quot;</span></span><br><span class="line">sentinel monitor hmaster 192.168.150.101 7001 2</span><br><span class="line">sentinel down-after-milliseconds hmaster 5000</span><br><span class="line">sentinel failover-timeout hmaster 60000</span><br></pre></td></tr></table></figure><ul><li><code>sentinel announce-ip &quot;192.168.150.101&quot;</code>：声明当前sentinel的ip</li><li><code>sentinel monitor hmaster 192.168.150.101 7001 2</code>：指定集群的主节点信息 <ul><li><code>hmaster</code>：主节点名称，自定义，任意写</li><li><code>192.168.150.101 7001</code>：主节点的ip和端口</li><li><code>2</code>：认定<code>master</code>下线时的<code>quorum</code>值</li></ul></li><li><code>sentinel down-after-milliseconds hmaster 5000</code>：声明master节点超时多久后被标记下线</li><li><code>sentinel failover-timeout hmaster 60000</code>：在第一次故障转移失败后多久再次重试</li></ul><p>sentinel<strong>选举leader的依据</strong>是什么？</p><ul><li>票数超过sentinel节点数量1半</li><li>票数超过quorum数量</li><li>一般情况下最先发起failover的节点会当选</li></ul><p>sentinel<strong>从slave中选取master的依据</strong>是什么？</p><ul><li>首先会判断slave节点与master节点断开时间长短，如果超过<code>down-after-milliseconds`` * 10</code>则会排除该slave节点</li><li>然后判断slave节点的<code>slave-priority</code>值，越小优先级越高，如果是0则永不参与选举（默认都是1）。</li><li>如果<code>slave-prority</code>一样，则判断slave节点的<code>offset</code>值，越大说明数据越新，优先级越高</li><li>最后是判断slave节点的<code>run_id</code>大小，越小优先级越高（<code>通过info server可以查看run_id</code>）。</li></ul><h4 id="Redis分片集群"><a href="#Redis分片集群" class="headerlink" title="Redis分片集群"></a>Redis分片集群</h4><img src="/img/Redis面试/1.6.png" alt="image-20240826144348383" style="zoom: 50%;" /><h5 id="集群配置"><a href="#集群配置" class="headerlink" title="集群配置"></a>集群配置</h5><ul><li><pre><code class="bash">port 7000cluster-enabled yescluster-config-file nodes.confcluster-node-timeout 5000appendonly yes<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  其中有3个我们没见过的参数：</span><br><span class="line"></span><br><span class="line">  - `cluster-enabled`：是否开启集群模式</span><br><span class="line">  - `cluster-config-file`：集群模式的配置文件名称，无需手动创建，由集群自动维护</span><br><span class="line">  - `cluster-node-timeout`：集群中节点之间心跳超时时间</span><br><span class="line"></span><br><span class="line">- ```bash</span><br><span class="line">  # 进入任意节点容器</span><br><span class="line">  docker exec -it r1 bash</span><br><span class="line">  # 然后，执行命令</span><br><span class="line">  redis-cli --cluster create --cluster-replicas 1 \</span><br><span class="line">  192.168.150.101:7001 192.168.150.101:7002 192.168.150.101:7003 \</span><br><span class="line">  192.168.150.101:7004 192.168.150.101:7005 192.168.150.101:7006</span><br></pre></td></tr></table></figure>命令说明：- `redis-cli --cluster`：代表集群操作命令- `create`：代表是创建集群- `--cluster-replicas 1` ：指定集群中每个`master`的副本个数为1  - 此时`节点总数 ÷ (replicas + 1)` 得到的就是`master`的数量`n`。因此节点列表中的前`n`个节点就是`master`，其它节点都是`slave`节点，随机分配到不同`master`</code></pre></li><li><p>Redis分片集群如何判断某个key应该在哪个实例？</p><ul><li>将16384个插槽分配到不同的实例</li><li>根据key计算哈希值，对16384取余</li><li>余数作为插槽，寻找插槽所在实例即可</li></ul></li></ul><h4 id="Redis数据结构"><a href="#Redis数据结构" class="headerlink" title="Redis数据结构"></a>Redis数据结构</h4><ul><li><p>我们常用的<strong>Redis数据类型</strong>有5种，分别是：</p><ul><li>String</li><li>List</li><li>Set</li><li>SortedSet</li><li>Hash</li></ul></li><li><p>RedisObject</p><ul><li><p><img src="/img/Redis%E9%9D%A2%E8%AF%95/1.7.png" alt="image-20240826152116160"></p></li><li><p>Redis中的5种不同的数据类型采用的底层数据结构和编码方式如下：</p><table><thead><tr><th align="center"><strong>数据类型</strong></th><th align="center"><strong>编码方式</strong></th></tr></thead><tbody><tr><td align="center">STRING</td><td align="center"><code>int</code>、<code>embstr</code>、<code>raw</code></td></tr><tr><td align="center">LIST</td><td align="center"><code>LinkedList和ZipList</code>(3.2以前)、<code>QuickList</code>（3.2以后）</td></tr><tr><td align="center">SET</td><td align="center"><code>intset</code>、<code>HT</code></td></tr><tr><td align="center">ZSET</td><td align="center"><code>ZipList</code>（7.0以前）、<code>Listpack</code>（7.0以后）、<code>HT</code>、<code>SkipList</code></td></tr><tr><td align="center">HASH</td><td align="center"><code>ZipList</code>（7.0以前）、<code>Listpack</code>（7.0以后）、<code>HT</code></td></tr></tbody></table></li></ul></li><li><p>SkipList</p><ul><li>SkipList（跳表）首先是链表，但与传统链表相比有几点差异：<ul><li>元素按照升序排列存储</li><li>节点可能包含多个指针，指针跨度不同。</li></ul></li><li>SkipList的特点<ul><li>跳跃表是一个有序的双向链表</li><li>每个节点都可以包含多层指针，层数是1到32之间的随机数</li><li>不同层指针到下一个节点的跨度不同，层级越高，跨度越大</li><li>增删改查效率与红黑树基本一致，实现却更为简单。但空间复杂度高</li></ul></li></ul></li><li><p>SortedSet</p><p><strong>面试题</strong>：Redis的<code>SortedSet</code>底层的数据结构是怎样的？</p><p><strong>答</strong>：SortedSet是有序集合，底层的存储的每个数据都包含element和score两个值。score是得分，element则是字符串值。SortedSet会根据每个element的score值排序，形成有序集合。</p><p>它支持的操作很多，比如：</p><ul><li>根据element查询score值</li><li>按照score值升序或降序查询element</li></ul><p>要实现根据element查询对应的score值，就必须实现element与score之间的键值映射。SortedSet底层是基于<strong>HashTable</strong>来实现的。</p><p>要实现对score值排序，并且查询效率还高，就需要有一种高效的有序数据结构，SortedSet是基于<strong>跳表</strong>实现的。</p><p>加分项：因为SortedSet底层需要用到两种数据结构，对内存占用比较高。因此Redis底层会对SortedSet中的元素大小做判断。如果<strong>元素大小小于128</strong>且<strong>每个元素都小于64字节</strong>，SortedSet底层会采用<strong>ZipList</strong>，也就是<strong>压缩列</strong>表来代替<strong>HashTable</strong>和<strong>SkipList</strong></p><p>不过，<code>ZipList</code>存在连锁更新问题，因此而在Redis7.0版本以后，<code>ZipList</code>又被替换为<strong>Listpack</strong>（紧凑列表）。</p></li></ul><h4 id="Redis内存回收"><a href="#Redis内存回收" class="headerlink" title="Redis内存回收"></a>Redis内存回收</h4><h5 id="过期KEY处理"><a href="#过期KEY处理" class="headerlink" title="过期KEY处理"></a>过期KEY处理</h5><ul><li><p>RedisKey的TTL记录方式：再RedisDB中通过一个哈希表记录每个Key的到期时间</p></li><li><p>Redis的过期KEY删除策略有两种：</p><ul><li>惰性删除：Redis会在每次访问KEY的时候判断当前KEY有没有设置过期时间，如果有，过期时间是否已经到期，判断到期后进行删除</li><li>周期删除：顾明思议是通过一个定时任务，周期性的抽样部分过期的key，然后执行删除。<ul><li>执行周期有两种：<ul><li><strong>SLOW模式：</strong>Redis会设置一个定时任务<code>serverCron()</code>，按照<code>server.hz</code>的频率来执行过期key清理</li><li><strong>FAST模式：</strong>Redis的每个事件循环前执行过期key清理（事件循环就是NIO事件处理的循环）。</li></ul></li></ul></li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
